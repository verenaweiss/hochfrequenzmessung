<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Ergebnisinterpretation – Hochfrequente Strahlung im Massivholzbau</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="quarto.css">
<link rel="stylesheet" href="interpretation.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Hochfrequente Strahlung im Massivholzbau</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./projects.html"> 
<span class="menu-text">Ziel des Projektes</span></a>
  </li>  
  <li class="nav-item dropdown ">
    <a class="nav-link dropdown-toggle" href="#" id="nav-menu-messungen" role="link" data-bs-toggle="dropdown" aria-expanded="false">
 <span class="menu-text">Messungen</span>
    </a>
    <ul class="dropdown-menu" aria-labelledby="nav-menu-messungen">    
        <li>
    <a class="dropdown-item" href="./messaufbau.html">
 <span class="dropdown-text">Messaufbau</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./messablauf.html">
 <span class="dropdown-text">Messablauf</span></a>
  </li>  
        <li>
    <a class="dropdown-item" href="./ergebnisse.html">
 <span class="dropdown-text">Ergebnisse</span></a>
  </li>  
    </ul>
  </li>
  <li class="nav-item">
    <a class="nav-link active" href="./interpretation.html" aria-current="page"> 
<span class="menu-text">Interpretation der Ergebnisse</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
    <a href="https://www.instagram.com/thoma_holz100/" title="" class="quarto-navigation-tool px-1" aria-label=""><i class="bi bi-instagram"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#erkentnisse-aus-den-messergebnissen" id="toc-erkentnisse-aus-den-messergebnissen" class="nav-link active" data-scroll-target="#erkentnisse-aus-den-messergebnissen">Erkentnisse aus den Messergebnissen</a></li>
  <li><a href="#aussagekraft-und-nutzen" id="toc-aussagekraft-und-nutzen" class="nav-link" data-scroll-target="#aussagekraft-und-nutzen">Aussagekraft und Nutzen</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Ergebnisinterpretation</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<hr style="border: 1px solid #D8F004; opacity: 1;">
<section id="erkentnisse-aus-den-messergebnissen" class="level2">
<h2 class="anchored" data-anchor-id="erkentnisse-aus-den-messergebnissen">Erkentnisse aus den Messergebnissen</h2>
Wie bei den Ergebnissen bereits erwähnt, ist ein deutlicher Unterschied der Abschirmung zwischen der 17 cm dicken Holz100-Wand mit und ohne Dämmung erkennbar. Vor allem im Bereich von 4 bis 6 GHz, also bei höheren Frequenzen, trägt die Dämmung einen großen Beitrag zur Dämpfung bei. In diesem Intervall kommt es zu Differenzen zwischen den Wandaufbauten von bis zu 10 dB. Grund dafür ist die im Verhältnis zur Stärke des gesamten Wandaufbaus sehr dicke Dämmung von 12 cm. Diese hat bezogen auf die Gesamtdicke von 29 cm einen Anteil von ca. 40 %. <br> Um herauszufinden, ob die Holzfaserdämmplatte bessere Dämpfungseigenschaften als Holz100 aufweist, kann die 17 cm dicke Wand mit Dämmung mit der 30,6 cm dicken Wand ohne Dämmplatte verglichen werden, da diese Wandaufbauten ungefähr die gleiche Dicke haben.
<div class="image-with-caption">
<figure class="figure">
<img src="img/Grafik17und30.png" alt="Beschreibung des Bildes" class="figure-img">
<figcaption>
H100-W17 mit Dämmung und H100-W30 ohne Dämmung im Vergleich
</figcaption>
</figure>
</div>
<p>Wie in der Grafik oben erkennbar, dämpft die H100-W30 vor allem in den niedrigeren Frequenzen besser. Daraus lässt sich schließen, dass die Dämmung keinen besseren Dämpfwert als Holz100 aufweist. Dabei ist zu beachten, dass die 30,6 cm starke Wand um 1,6 cm dicker ist und der Unterschied daraus resultieren könnte. Holz schirmt laut diesen Ergebnissen elektromagnetische Wellen nahezu über den gesamten Frequenzbereich von 4 bis 6 GHz besser ab. <br> <br> Die Dämpfmittelwerte der H100-W25-Außenwände unterscheiden sich weniger als bei den H100-W17-Wänden (siehe „Messungen“, „Ergebnisse“). Dies liegt daran, dass die 8 cm dicke Dämmplatten nur rund 24 % der Gesamtstärke von 33 cm ausmacht. Der geringere Unterschied in der Materialstärke zwischen den Wandaufbauten könnte dieses Ergebnis erklären. <br> <br> Die Kurven der H100-W30-Wände verlaufen nahezu identisch (siehe “Ergebnisse”). Die 6 cm dicke Holzfaserdämmplatte macht nur 16 % der Gesamtstärke aus. Mit zunehmender Wandstärke steigt die Dämpfung bis 2 GHz stärker an, während der Anstieg darüber hinaus flacher verläuft. Dünnere Wände zeigen dagegen einen gleichmäßigeren Anstieg. Dies bestätigt, dass dickere Wände nicht nur insgesamt besser dämpfen, sondern besonders niederfrequente Strahlung effektiver abschirmen.</p>
<strong>Folgende Erkenntnisse lassen sich festhalten</strong>
<ul>
<li>
Grund für die besseren Dämpfungseigenschaften bei Wandaufbauten mit Holzfaserdämmung ist nicht die Dämmung an sich, sondern die zunehmende Stärke des gesamten Aufbaus.
</li>
<li>
Holz besitzt bessere Dämpfungseigenschaften gegenüber elektromagnetischer Strahlung als Holzfaserdämmung.
</li>
<li>
Dickere Holzwände bieten bereits bei niedrigen Frequenzen eine bessere Dämpfung und wirken sich auch bei hohen Frequenzen positiv aus.
</li>
<li>
Die Hypothese wird bestätigt: Je höher die Frequenz der elektromagnetischen Strahlung, desto stärker wird sie von Holz100-Wänden abgeschirmt.
</li>
</ul>
</section>
<section id="aussagekraft-und-nutzen" class="level2">
<h2 class="anchored" data-anchor-id="aussagekraft-und-nutzen">Aussagekraft und Nutzen</h2>
<p>Es ist wichtig zu erwähnen, dass die Messungen unter Laborbedingungen durchgeführt wurden. In realen Anwendungen, beispielsweise in bestehenden Gebäuden, sind abweichende Ergebnisse zu erwarten – insbesondere, wenn die Räume nicht aus einem einzigen Material bestehen oder nicht exakt den untersuchten Aufbauten entsprechen. Zudem können Beschichtungen, Fenster, Fensterrahmen, Türen und Verbindungsstellen die Dämpfung elektromagnetischer Strahlung beeinflussen oder einschränken. <br> <br> Eine hohe Abschirmung von hochfrequenter elektromagnetischer Strahlung ist nicht immer positiv zu sehen. In einem Haus, welches kaum Strahlung wie zum Beispiel 4G oder 5G durchlässt, müssen Mobiltelefone, WLAN-Router und andere drahtlose Geräte mit viel mehr Sendeleistung arbeiten. Das wirkt dem gewünschten Effekt, elektromagnetische Wellen außerhalb des Wohnraumes zu halten, entgegen und bewirkt das Gegenteil. Zudem halten die gut dämpfenden Wände die im Innenraum erzeugte Strahlung zurück. Dies kann nicht nur zu einem erhöhten Energieverbrauch und einer verkürzten Akkulaufzeit bei mobilen Geräten führen, sondern auch zu Empfangsproblemen, insbesondere bei größeren Entfernungen zum WLAN-Router. In solchen Fällen sind zusätzliche WLAN-Verstärker erforderlich, was strahlungsbewusste Nutzer meist vermeiden möchten, da dadurch die Strahlung wieder verstärkt wird. <br> <br> Eine mögliche Lösung wäre eine gezielte Auswahl der Wandstärke je nach Raumnutzung, damit je nach Zweck eine Balance zwischen Strahlungsabschirmung und Funkverfügbarkeit besteht. In Wohnräumen, Büros oder anderen Bereichen, in denen drahtlose Geräte häufig verwendet werden, wäre der Einsatz von dünneren Wänden sinnvoll. Somit würde die Signalübertragung von WLAN, Mobilfunk und anderen drahtlosen Technologien trotzdem ausreichend sein und es würde verhindert, dass Geräte mit erhöhter Sende- beziehungsweise Empfangsleistung arbeiten müssen. <br> <br> In Schlafräumen oder Erholungsbereichen, in denen elektromagnetische Strahlung unerwünscht ist, könnte eine effektive Abschirmung durch dickere Wände mit höheren Dämpfungswerten erreicht werden. Dies wäre besonders vorteilhaft für Menschen, die empfindlich auf elektromagnetische Felder reagieren oder die Strahlenbelastung in ihrem Wohnraum so gering wie möglich halten möchten.</p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>